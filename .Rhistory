# boundary between Cat3 and Cat2
# grabbing the coefficients
weights <- (weightsOptim[,1]-weightsOptim[,2])[2:3]
bias <- (weightsOptim[,1]-weightsOptim[,2])[1]
# the boundary
x <- seq(min(categoriesDf["Y"]), max(categoriesDf["Y"]),
length.out = (noCat1+noCat2+noCat3)*10)
y <- -(weights[1]/weights[2])*x + (-bias)/weights[2]
boundaryDf_32 <- data.frame(Y=x, X=y,
Name=rep("Boundary_32", length(x)))
# boundary between Cat3 and Cat1
# grabbing the coefficients
weights <- (weightsOptim[,1]-weightsOptim[,3])[2:3]
bias <- (weightsOptim[,1]-weightsOptim[,3])[1]
# the boundary
x <- seq(min(categoriesDf["Y"]), max(categoriesDf["Y"]),
length.out = (noCat1+noCat2+noCat3)*10)
y <- -(weights[1]/weights[2])*x + (-bias)/weights[2]
boundaryDf_31 <- data.frame(Y=x, X=y,
Name=rep("Boundary_31", length(x)))
# boundary between Cat2 and Cat1
# grabbing the coefficients
weights <- (weightsOptim[,2]-weightsOptim[,3])[2:3]
bias <- (weightsOptim[,2]-weightsOptim[,3])[1]
# the boundary
x <- seq(min(categoriesDf["Y"]), max(categoriesDf["Y"]),
length.out = (noCat1+noCat2+noCat3)*10)
y <- -(weights[1]/weights[2])*x + (-bias)/weights[2]
boundaryDf_21 <- data.frame(Y=x, X=y,
Name=rep("Boundary_21", length(x)))
## Trimming the boundaries
# boundary 21
min_y <- min(categoriesDf[categoriesDf[,3]=="Cat3",1])
max_y <- max(categoriesDf[categoriesDf[,3]=="Cat3",1])
min_x <- min(categoriesDf[categoriesDf[,3]=="Cat3",2])
max_x <- max(categoriesDf[categoriesDf[,3]=="Cat3",2])
boundaryDf_21a <- boundaryDf_21
boundaryDf_21a[boundaryDf_21[,1]==0] <- 0
trim_21 <- (boundaryDf_21a[,1]>max_y | boundaryDf_21a[,1]<min_y) | (boundaryDf_21a[,2]>max_x | boundaryDf_21a[,2]<min_x)
bound_21_trimmed <- boundaryDf_21a[trim_21,]
# boundary 32
min_y <- min(categoriesDf[categoriesDf[,3]=="Cat1",1])
max_y <- max(categoriesDf[categoriesDf[,3]=="Cat1",1])
min_x <- min(categoriesDf[categoriesDf[,3]=="Cat1",2])
max_x <- max(categoriesDf[categoriesDf[,3]=="Cat1",2])
boundaryDf_32a <- boundaryDf_32
boundaryDf_32a[boundaryDf_32[,1]==0] <- 0
trim_32 <- (boundaryDf_32a[,1]>max_y | boundaryDf_32a[,1]<min_y) & (boundaryDf_32a[,2]>max_x | boundaryDf_32a[,2]<min_x)
bound_32_trimmed <- boundaryDf_32a[trim_32,]
# boundary 31
min_y <- min(categoriesDf[categoriesDf[,3]=="Cat2",1])
max_y <- max(categoriesDf[categoriesDf[,3]=="Cat2",1])
min_x <- min(categoriesDf[categoriesDf[,3]=="Cat2",2])
max_x <- max(categoriesDf[categoriesDf[,3]=="Cat2",2])
boundaryDf_31a <- boundaryDf_31
boundaryDf_31a[boundaryDf_31[,1]==0] <- 0
trim_31 <- (boundaryDf_31a[,1]>max_y | boundaryDf_31a[,1]<min_y) | (boundaryDf_31a[,2]>max_x | boundaryDf_31a[,2]<min_x)
bound_31_trimmed <- boundaryDf_31a[trim_31,]
# plotting
plotCategories2()
```
categoriesDf <- create_dataset(noCat1, noCat2, noCat3, c(5, 50), c(5, 220), c(15, 90),
c(2,20), c(2,30), c(2,50), -0.5, 0.3, 0.1)
noCat1 <- 60; noCat2 <- 30; noCat3 <- 80;
categoriesDf <- create_dataset(noCat1, noCat2, noCat3, c(5, 50), c(7, 220), c(13, 120),
c(2,20), c(2,30), c(2,50), -0.5, 0.3, 0.1)
categoriesDf <- cbind(categoriesDf,
target1 = c(rep(0, noCat1), rep(0, noCat2), rep(1, noCat3)),
target2 = c(rep(0, noCat1), rep(1, noCat2), rep(0, noCat3)),
target3 = c(rep(1, noCat1), rep(0, noCat2), rep(0, noCat3))
)
X <- as.matrix(cbind(ind=rep(1, nrow(categoriesDf)),
categoriesDf[,c("Y", "X")]))
Y <- cbind(target1 = c(rep(0, noCat1), rep(0, noCat2), rep(1, noCat3)),
target2 = c(rep(0, noCat1), rep(1, noCat2), rep(0, noCat3)),
target3 = c(rep(1, noCat1), rep(0, noCat2), rep(0, noCat3))
)
weightsOptim <- solve(t(X)%*%X) %*% t(X) %*% Y
# Compute predictions
predictions <- X %*% weightsOptim
predictions
# Classify according to the argmax criterion
predictedLabels <- rep("Cat1", nrow(categoriesDf))
predictedLabels[(predictions==apply(predictions, 1, max))[,1]] <- "Cat3"
predictedLabels[(predictions==apply(predictions, 1, max))[,2]] <- "Cat2"
predictedLabels
# Classification algorithm performance
performance <- table(categoriesDf$Name, predictedLabels)
performance
performanceProp <- prop.table(performance, 1)
performanceProp
```
We can finally visualise the results of the analysis in a plot where the boundaries between categories are drawn.
weights <- (weightsOptim[,2]-weightsOptim[,3])[2:3]
bias <- (weightsOptim[,2]-weightsOptim[,3])[1]
x <- seq(min(categoriesDf["Y"]), max(categoriesDf["Y"]),
length.out = (noCat1+noCat2+noCat3)*10)
y <- -(weights[1]/weights[2])*x + (-bias)/weights[2]
boundaryDf_12 <- data.frame(Y=x, X=y,
Name=rep("Boundary_12", length(x)))
# Between Cat1 and Cat3
weights <- (weightsOptim[,1]-weightsOptim[,3])[2:3]
bias <- (weightsOptim[,1]-weightsOptim[,3])[1]
x <- seq(min(categoriesDf["Y"]), max(categoriesDf["Y"]),
length.out = (noCat1+noCat2+noCat3)*10)
y <- -(weights[1]/weights[2])*x + (-bias)/weights[2]
boundaryDf_13 <- data.frame(Y=x, X=y,
Name=rep("Boundary_13", length(x)))
# Between Cat2 and Cat3
weights <- (weightsOptim[,1]-weightsOptim[,2])[2:3]
bias <- (weightsOptim[,1]-weightsOptim[,2])[1]
x <- seq(min(categoriesDf["Y"]), max(categoriesDf["Y"]),
length.out = (noCat1+noCat2+noCat3)*10)
y <- -(weights[1]/weights[2])*x + (-bias)/weights[2]
boundaryDf_23 <- data.frame(Y=x, X=y,
Name=rep("Boundary_23", length(x)))
## Trimming the boundaries for the chart
# Between Cat1 and Cat2
min_y <- min(categoriesDf[categoriesDf[,3]=="Cat3",1])
max_y <- max(categoriesDf[categoriesDf[,3]=="Cat3",1])
min_x <- min(categoriesDf[categoriesDf[,3]=="Cat3",2])
max_x <- max(categoriesDf[categoriesDf[,3]=="Cat3",2])
boundaryDf_12a <- boundaryDf_12
boundaryDf_12a[boundaryDf_12[,1]==0] <- 0
trim_12 <- (boundaryDf_12a[,1]>max_y | boundaryDf_12a[,1]<min_y) |
(boundaryDf_12a[,2]>max_x | boundaryDf_12a[,2]<min_x)
bound_12_trimmed <- boundaryDf_12a[trim_12,]
# Between Cat1 and Cat3
min_y <- min(categoriesDf[categoriesDf[,3]=="Cat2",1])
max_y <- max(categoriesDf[categoriesDf[,3]=="Cat2",1])
min_x <- min(categoriesDf[categoriesDf[,3]=="Cat2",2])
max_x <- max(categoriesDf[categoriesDf[,3]=="Cat2",2])
boundaryDf_13a <- boundaryDf_13
boundaryDf_13a[boundaryDf_13[,1]==0] <- 0
trim_13 <- (boundaryDf_13a[,1]>max_y | boundaryDf_13a[,1]<min_y) |
(boundaryDf_13a[,2]>max_x | boundaryDf_13a[,2]<min_x)
bound_13_trimmed <- boundaryDf_13a[trim_13,]
# Between Cat2 and Cat3
min_y <- min(categoriesDf[categoriesDf[,3]=="Cat1",1])
max_y <- max(categoriesDf[categoriesDf[,3]=="Cat1",1])
min_x <- min(categoriesDf[categoriesDf[,3]=="Cat1",2])
max_x <- max(categoriesDf[categoriesDf[,3]=="Cat1",2])
boundaryDf_23a <- boundaryDf_23
boundaryDf_23a[boundaryDf_23[,1]==0] <- 0
trim_23 <- (boundaryDf_23a[,1]>max_y | boundaryDf_23a[,1]<min_y) &
(boundaryDf_23a[,2]>max_x | boundaryDf_23a[,2]<min_x)
bound_23_trimmed <- boundaryDf_23a[trim_23,]
## Plot the final graph
plotCategories()
min_y <- min(categoriesDf[categoriesDf[,3]=="Cat2",1])
max_y <- max(categoriesDf[categoriesDf[,3]=="Cat2",1])
min_x <- min(categoriesDf[categoriesDf[,3]=="Cat2",2])
max_x <- max(categoriesDf[categoriesDf[,3]=="Cat2",2])
boundaryDf_13a <- boundaryDf_13
boundaryDf_13a[boundaryDf_13[,1]==0] <- 0
trim_13 <- (boundaryDf_13a[,1]>max_y | boundaryDf_13a[,1]<min_y) &
(boundaryDf_13a[,2]>max_x | boundaryDf_13a[,2]<min_x)
bound_13_trimmed <- boundaryDf_13a[trim_13,]
plotCategories()
# Between Cat1 and Cat2
min_y <- min(categoriesDf[categoriesDf[,3]=="Cat3",1])
max_y <- max(categoriesDf[categoriesDf[,3]=="Cat3",1])
min_x <- min(categoriesDf[categoriesDf[,3]=="Cat3",2])
max_x <- max(categoriesDf[categoriesDf[,3]=="Cat3",2])
boundaryDf_12a <- boundaryDf_12
boundaryDf_12a[boundaryDf_12[,1]==0] <- 0
trim_12 <- (boundaryDf_12a[,1]>max_y | boundaryDf_12a[,1]<min_y) |
(boundaryDf_12a[,2]>max_x | boundaryDf_12a[,2]<min_x)
bound_12_trimmed <- boundaryDf_12a[trim_12,]
# Between Cat1 and Cat3
min_y <- min(categoriesDf[categoriesDf[,3]=="Cat2",1])
max_y <- max(categoriesDf[categoriesDf[,3]=="Cat2",1])
min_x <- min(categoriesDf[categoriesDf[,3]=="Cat2",2])
max_x <- max(categoriesDf[categoriesDf[,3]=="Cat2",2])
boundaryDf_13a <- boundaryDf_13
boundaryDf_13a[boundaryDf_13[,1]==0] <- 0
trim_13 <- (boundaryDf_13a[,1]>max_y | boundaryDf_13a[,1]<min_y) |
(boundaryDf_13a[,2]>max_x | boundaryDf_13a[,2]<min_x)
bound_13_trimmed <- boundaryDf_13a[trim_13,]
# Between Cat2 and Cat3
min_y <- min(categoriesDf[categoriesDf[,3]=="Cat1",1])
max_y <- max(categoriesDf[categoriesDf[,3]=="Cat1",1])
min_x <- min(categoriesDf[categoriesDf[,3]=="Cat1",2])
max_x <- max(categoriesDf[categoriesDf[,3]=="Cat1",2])
boundaryDf_23a <- boundaryDf_23
boundaryDf_23a[boundaryDf_23[,1]==0] <- 0
trim_23 <- (boundaryDf_23a[,1]>max_y | boundaryDf_23a[,1]<min_y) &
(boundaryDf_23a[,2]>max_x | boundaryDf_23a[,2]<min_x)
bound_23_trimmed <- boundaryDf_23a[trim_23,]
plotCategories()
create_dataset <- function(noCat1, noCat2, noCat3, muCat1, muCat2, muCat3, sdCat1,
sdCat2, sdCat3, rhoCat1, rhoCat2, rhoCat3, seed=1000) {
sigmaCat1 <- sigmaXY(rho=rhoCat1, sdX=sdCat1[1], sdY=sdCat1[2])
sigmaCat2 <- sigmaXY(rho=rhoCat2, sdX=sdCat2[1], sdY=sdCat2[2])
sigmaCat3 <- sigmaXY(rho=rhoCat3, sdX=sdCat3[1], sdY=sdCat3[2])
cat1 <- genBVN(noCat1, muCat1, sigmaCat1, seed = seed)
cat2 <- genBVN(noCat2, muCat2, sigmaCat2, seed = seed+1)
cat3 <- genBVN(noCat3, muCat3, sigmaCat3, seed = seed+2)
categoriesDf <- as.data.frame(rbind(cat1,cat2,cat3))
Category <- c(rep("Cat1", noCat1), rep("Cat2", noCat2), rep("Cat3", noCat3))
categoriesDf <- cbind(categoriesDf, Category)
colnames(categoriesDf) <- c("Y", "X", "Name")
return(categoriesDf)
}
if (!require("mvtnorm")) install.packages("mvtnorm")
if (!require("ggplot2")) install.packages("ggplot2")
if (!require("magrittr")) install.packages("magrittr")
# generate means for our mixture
gen2c2dMixture <- function(noObs=c(100, 100), noGaussians=10, mixtureProb=rep(1/noGaussians, noGaussians), seed=7851) {
set.seed(seed)
# producing means of our bivariate Gaussians
meansC1 <- rmvnorm(noGaussians, mean = c(1,0), sigma = diag(2))
meansC2 <- rmvnorm(noGaussians, mean = c(0,1), sigma = diag(2))
# for each observation we first randomly select one Gaussian and then generate a point according to the parameters of that Gaussian
whichGaussianC1 <- sample(nrow(meansC1), noObs[1], mixtureProb, replace = TRUE)
whichGaussianC2 <- sample(nrow(meansC2), noObs[2], mixtureProb, replace = TRUE)
# now drawing samples from selected bivariate Gaussians
drawsC1 <- whichGaussianC1 %>% sapply(function(x) rmvnorm(1, mean = meansC1[x,], sigma = diag(2)/5)) %>% t()
drawsC2 <- whichGaussianC2 %>% sapply(function(x) rmvnorm(1, mean = meansC2[x,], sigma = diag(2)/5)) %>% t()
# combining and labeling
dataset <- data.frame(rbind(drawsC1, drawsC2), Y=c(rep("C1", noObs[1]), rep("C2", noObs[2])), stringsAsFactors=FALSE)
return(dataset)
}
dataset <- gen2c2dMixture(noObs=c(100, 100))
dataset
plot2dClasses <- function(dataset) {
ggplot(data = dataset, aes(x = X1, y = X2,
colour=Y, fill=Y)) +
geom_point() +
xlab("X1") +
ylab("X2") +
theme_bw(base_size = 14, base_family = "Helvetica") +
scale_color_manual("Y",
values = c("C1" = "blue", "C2" = "red"))
}
plot2dClasses(dataset)
noObs <- nrow(dataset)
noObs <- nrow(dataset)
distanceMatrix <- matrix(NA, noObs, noObs) # to pre-allocate memory
probe <- as.numeric(dataset[obs, 1:2])
probe <- as.numeric(dataset[1, 1:2])
probe
dataset
probeExtended <- matrix(rep(probe, each=noObs), nrow=noObs)
probeExtended
distanceMatrix[obs, ] <- (rowSum((dataset[,1:2]-probeExtended)^p))^(1/p)
distanceMatrix[obs, ] <- (rowSums((dataset[,1:2]-probeExtended)^p))^(1/p)
k <- 1 # set the number of neighbours
p <- 2 # specify the type of distance (e.g. 2 is Euclidean)
distanceMatrix[obs, ] <- (rowSums((dataset[,1:2]-probeExtended)^p))^(1/p)
distanceMatrix[obs, ] <- (rowSums(abs(dataset[,1:2]-probeExtended)^p))^(1/p) # Calculate distance
1
distanceMatrix[2, ] <- (rowSums(abs(dataset[,1:2]-probeExtended)^p))^(1/p) # Calculate distance
distanceMatrix
distanceMatrix[obs, ] <- (rowSums(abs(dataset[,1:2]-probeExtended)^p))^(1/p) # Calculate distance
for (obs in 1:noObs){
probe <- as.numeric(dataset[obs, 1:2]) # Observation X1 and X2
probeExtended <- matrix(rep(probe, each=noObs), nrow=noObs)
distanceMatrix[obs, ] <- (rowSums(abs(dataset[,1:2]-probeExtended)^p))^(1/p) # Calculate distance
}
distanceMatrix
neighbours <- apply(distanceMatrix, 2, order)
neighbours
neighbours <- apply(distanceMatrix, 2, order) %>% t() # send output to the transpose function
neighbours
head(neighbours)
dataset
dataset[,3]
dataset
gen2c2dMixture <- function(noObs=c(100, 100), noGaussians=10, mixtureProb=rep(1/noGaussians, noGaussians), seed=7851) {
set.seed(seed)
# producing means of our bivariate Gaussians
meansC1 <- rmvnorm(noGaussians, mean = c(1,0), sigma = diag(2))
meansC2 <- rmvnorm(noGaussians, mean = c(0,1), sigma = diag(2))
# for each observation we first randomly select one Gaussian and then generate a point according to the parameters of that Gaussian
whichGaussianC1 <- sample(nrow(meansC1), noObs[1], mixtureProb, replace = TRUE)
whichGaussianC2 <- sample(nrow(meansC2), noObs[2], mixtureProb, replace = TRUE)
# now drawing samples from selected bivariate Gaussians
drawsC1 <- whichGaussianC1 %>% sapply(function(x) rmvnorm(1, mean = meansC1[x,], sigma = diag(2)/5)) %>% t()
drawsC2 <- whichGaussianC2 %>% sapply(function(x) rmvnorm(1, mean = meansC2[x,], sigma = diag(2)/5)) %>% t()
# combining and labeling
dataset <- data.frame(rbind(drawsC1, drawsC2),
Y=c(rep("C1", noObs[1]), rep("C2", noObs[2])),
Y=c(rep("C1", noObs[1]), rep("C2", noObs[2])),
stringsAsFactors=FALSE)
return(dataset)
}
dataset <- gen2c2dMixture(noObs=c(100, 100))
dataset
gen2c2dMixture <- function(noObs=c(100, 100), noGaussians=10, mixtureProb=rep(1/noGaussians, noGaussians), seed=7851) {
set.seed(seed)
# producing means of our bivariate Gaussians
meansC1 <- rmvnorm(noGaussians, mean = c(1,0), sigma = diag(2))
meansC2 <- rmvnorm(noGaussians, mean = c(0,1), sigma = diag(2))
# for each observation we first randomly select one Gaussian and then generate a point according to the parameters of that Gaussian
whichGaussianC1 <- sample(nrow(meansC1), noObs[1], mixtureProb, replace = TRUE)
whichGaussianC2 <- sample(nrow(meansC2), noObs[2], mixtureProb, replace = TRUE)
# now drawing samples from selected bivariate Gaussians
drawsC1 <- whichGaussianC1 %>% sapply(function(x) rmvnorm(1, mean = meansC1[x,], sigma = diag(2)/5)) %>% t()
drawsC2 <- whichGaussianC2 %>% sapply(function(x) rmvnorm(1, mean = meansC2[x,], sigma = diag(2)/5)) %>% t()
# combining and labeling
dataset <- data.frame(rbind(drawsC1, drawsC2),
Y=c(rep("C1", noObs[1]), rep("C2", noObs[2])),
Y=c(rep("0", noObs[1]), rep("1", noObs[2])),
stringsAsFactors=FALSE)
return(dataset)
}
dataset <- gen2c2dMixture(noObs=c(100, 100))
dataset
noObs <- nrow(dataset)
distanceMatrix <- matrix(NA, noObs, noObs) # to pre-allocate memory
for (obs in 1:noObs){
probe <- as.numeric(dataset[obs, 1:2]) # Observation X1 and X2
probeExtended <- matrix(rep(probe, each=noObs), nrow=noObs)
distanceMatrix[obs, ] <- (rowSums(abs(dataset[,1:2]-probeExtended)^p))^(1/p) # Calculate distance
}
neighbours <- apply(distanceMatrix, 2, order) %>% t() # send output to the transpose function
head(neighbours)
prob <- predictedClasses <- rep(NA, noObs) # initialise frame for probabilities and predicted classes
gen2c2dMixture <- function(noObs=c(100, 100), noGaussians=10, mixtureProb=rep(1/noGaussians, noGaussians), seed=7851) {
set.seed(seed)
# producing means of our bivariate Gaussians
meansC1 <- rmvnorm(noGaussians, mean = c(1,0), sigma = diag(2))
meansC2 <- rmvnorm(noGaussians, mean = c(0,1), sigma = diag(2))
# for each observation we first randomly select one Gaussian and then generate a point according to the parameters of that Gaussian
whichGaussianC1 <- sample(nrow(meansC1), noObs[1], mixtureProb, replace = TRUE)
whichGaussianC2 <- sample(nrow(meansC2), noObs[2], mixtureProb, replace = TRUE)
# now drawing samples from selected bivariate Gaussians
drawsC1 <- whichGaussianC1 %>% sapply(function(x) rmvnorm(1, mean = meansC1[x,], sigma = diag(2)/5)) %>% t()
drawsC2 <- whichGaussianC2 %>% sapply(function(x) rmvnorm(1, mean = meansC2[x,], sigma = diag(2)/5)) %>% t()
# combining and labeling
dataset <- data.frame(rbind(drawsC1, drawsC2),
Y=c(rep("C1", noObs[1]), rep("C2", noObs[2])),
Y=c(rep("1", noObs[1]), rep("0", noObs[2])),
stringsAsFactors=FALSE)
return(dataset)
}
dataset <- gen2c2dMixture(noObs=c(100, 100))
dataset
plot2dClasses(dataset)
k <- 1 # set the number of neighbours
p <- 2 # specify the type of distance (e.g. 2 is Euclidean)
noObs <- nrow(dataset)
distanceMatrix <- matrix(NA, noObs, noObs) # to pre-allocate memory
for (obs in 1:noObs){
probe <- as.numeric(dataset[obs, 1:2]) # Observation X1 and X2
probeExtended <- matrix(rep(probe, each=noObs), nrow=noObs)
distanceMatrix[obs, ] <- (rowSums(abs(dataset[,1:2]-probeExtended)^p))^(1/p) # Calculate distance
}
neighbours <- apply(distanceMatrix, 2, order) %>% t() # send output to the transpose function
head(neighbours)
prob <- predictedClasses <- rep(NA, noObs) # initialise frame for probabilities and predicted classes
prob[2] <- mean(dataset[neighbours[2:(k+1), obs],4])  # calculate the probability of it being a 0 or 1
prob[1] <- mean(dataset[neighbours[2:(k+1), obs],4])  # calculate the probability of it being a 0 or 1
dataset
prob <- predictedClasses <- rep(NA, noObs) # initialise frame for probabilities and predicted classes
for (obs in 1:noObs) {
prob[obs] <- mean(dataset[neighbours[2:(k+1), obs],4])  # calculate the probability of it being a 0 or 1
# from 2 onwards to avoid comparison with itself
}
prob[1] <- mean(dataset[neighbours[2:(k+1), obs],4])  # calculate the probability of it being a 0 or 1
prob <- predictedClasses <- rep(NA, noObs) # initialise frame for probabilities and predicted classes
prob
prob[1] <- mean(dataset[neighbours[2:(k+1), obs],4])
head(neighbours)
gen2c2dMixture <- function(noObs=c(100, 100), noGaussians=10, mixtureProb=rep(1/noGaussians, noGaussians), seed=7851) {
set.seed(seed)
# producing means of our bivariate Gaussians
meansC1 <- rmvnorm(noGaussians, mean = c(1,0), sigma = diag(2))
meansC2 <- rmvnorm(noGaussians, mean = c(0,1), sigma = diag(2))
# for each observation we first randomly select one Gaussian and then generate a point according to the parameters of that Gaussian
whichGaussianC1 <- sample(nrow(meansC1), noObs[1], mixtureProb, replace = TRUE)
whichGaussianC2 <- sample(nrow(meansC2), noObs[2], mixtureProb, replace = TRUE)
# now drawing samples from selected bivariate Gaussians
drawsC1 <- whichGaussianC1 %>% sapply(function(x) rmvnorm(1, mean = meansC1[x,], sigma = diag(2)/5)) %>% t()
drawsC2 <- whichGaussianC2 %>% sapply(function(x) rmvnorm(1, mean = meansC2[x,], sigma = diag(2)/5)) %>% t()
# combining and labeling
dataset <- data.frame(rbind(drawsC1, drawsC2),
Y=c(rep("C1", noObs[1]), rep("C2", noObs[2])),
Y=c(rep(1, noObs[1]), rep(0, noObs[2])),
stringsAsFactors=FALSE)
return(dataset)
}
dataset <- gen2c2dMixture(noObs=c(100, 100))
dataset
noObs <- nrow(dataset)
distanceMatrix <- matrix(NA, noObs, noObs) # to pre-allocate memory
for (obs in 1:noObs){
probe <- as.numeric(dataset[obs, 1:2]) # Observation X1 and X2
probeExtended <- matrix(rep(probe, each=noObs), nrow=noObs)
distanceMatrix[obs, ] <- (rowSums(abs(dataset[,1:2]-probeExtended)^p))^(1/p) # Calculate distance
}
neighbours <- apply(distanceMatrix, 2, order) %>% t() # send output to the transpose function
head(neighbours)
prob <- predictedClasses <- rep(NA, noObs) # initialise frame for probabilities and predicted classes
prob[1] <- mean(dataset[neighbours[2:(k+1), obs],4])  # calculate the probability of it being a 0 or 1
prob <- predictedClasses <- rep(NA, noObs) # initialise frame for probabilities and predicted classes
for (obs in 1:noObs) {
prob[obs] <- mean(dataset[neighbours[2:(k+1), obs],4])  # calculate the probability of it being a 0 or 1
# from 2 onwards to avoid comparison with itself
if (prob[obs] > 0.5) {predictedClasses[obs] <-1
} else {predictedClasses[obs] <- 0}
}
predictedClasses
table(predictedClasses, dataset[,4])
mean(predictedClasses == dataset[,4])
mean(predictedClasses != dataset[,4]) # mis-classification error
prob <- predictedClasses <- rep(NA, noObs) # initialise frame for probabilities and predicted classes
for (obs in 1:noObs) {
prob[obs] <- mean(dataset[neighbours[obs, 2:(k+1)],4])  # calculate the probability of it being a 0 or 1
# from 2 onwards to avoid comparison with itself
if (prob[obs] > 0.5) {predictedClasses[obs] <-1
} else {predictedClasses[obs] <- 0}
}
table(predictedClasses, dataset[,4])
mean(predictedClasses == dataset[,4]) # accuracy
mean(predictedClasses != dataset[,4]) # mis-classification error
k <- 15 # set the number of neighbours
noObs <- nrow(dataset)
distanceMatrix <- matrix(NA, noObs, noObs) # to pre-allocate memory
for (obs in 1:noObs){
probe <- as.numeric(dataset[obs, 1:2]) # Observation X1 and X2
probeExtended <- matrix(rep(probe, each=noObs), nrow=noObs)
distanceMatrix[obs, ] <- (rowSums(abs(dataset[,1:2]-probeExtended)^p))^(1/p) # Calculate distance
}
# Allocate observations to classes
neighbours <- apply(distanceMatrix, 2, order) %>% t() # send output to the transpose function
head(neighbours)
prob <- predictedClasses <- rep(NA, noObs) # initialise frame for probabilities and predicted classes
for (obs in 1:noObs) {
prob[obs] <- mean(dataset[neighbours[obs, 2:(k+1)],4])  # calculate the probability of it being a 0 or 1
# from 2 onwards to avoid comparison with itself
if (prob[obs] > 0.5) {predictedClasses[obs] <-1
} else {predictedClasses[obs] <- 0}
}
# Check misclassification error
table(predictedClasses, dataset[,4])
mean(predictedClasses == dataset[,4]) # accuracy
mean(predictedClasses != dataset[,4]) # mis-classification error
install.packages("shiny")
source.with.encoding('~/Dropbox/MSc Data Science/Courses/006 - Machine Learning (14D005)/Homework/TA seminars/Seminar1/homework/HW1-StefanoCostantini_v2.Rmd', encoding='UTF-8')
library(ElemStatLearn)
install.packages("ElemStatLearn")
require(class)
mixture.example$x
mixture.example
mixture.example$x
library(ElemStatLearn)
mixture.example()
mixture.example
x <- mixture.example$x
g <- mixture.example$y
x
g
xnew <- mixture.example$xnew
xnew
mod15 <- knn(x, xnew, g, k=15, prob=TRUE)
prob <- attr(mod15, "prob")
prob
prob <- ifelse(mod15=="1", prob, 1-prob)
prob
px1 <- mixture.example$px1
px2 <- mixture.example$px2
px1
px2
prob15 <- matrix(prob, length(px1), length(px2))
par(mar=rep(2,4))
contour(px1, px2, prob15, levels=0.5, labels="", xlab="", ylab="", main=
"15-nearest neighbour", axes=FALSE)
points(x, col=ifelse(g==1, "coral", "cornflowerblue"))
gd <- expand.grid(x=px1, y=px2)
points(gd, pch=".", cex=1.2, col=ifelse(prob15>0.5, "coral", "cornflowerblue"))
box()
mixture.example
mixture.example$px1
mixture.example$x
min(mixture.example$x[,1])
min(px1)
max(mixture.example$x[,1])
max(px1)
max(mixture.example$x[,2])
max(px2)
prob15
prob
mod15
mod15
mod15$
1
mod15$2
prob <- attr(mod15, "prob")
prob
length(xnew)
head(mod15
)length(xnew)
head(mod15)
>attr
?attr
head(prob)
unique(prob)
install.packages("devtools")
library(devtools)
library(devtools)
library(roxygen2)
setwd("~/Desktop/scklass")
ls
devtools:document()
devtools::document()
devtools:install()
devtools::install()
library(scklass)
?calcDistances
?knnClassifier
